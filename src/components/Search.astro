---
import { Sprite } from 'astro-icon'

export interface Props {
    id: string
    placeholder: string
    selector: string
    groupSelector?: string
}

const { id, placeholder, selector, groupSelector } = Astro.props as Props

const inlineStyle = `
    ${selector}[hidden] {
        display: none;
    }

`
---

<section>
    <label for={id}>
        <input type="text" id={id} placeholder={placeholder} />
        <div>
            <Sprite
                pack="heroicons-outline"
                name="search"
                size={24}
                aria-hidden="true"
            />
        </div>
        <span class="sr-only visually-hidden">Search</span>
    </label>
</section>

<style set:html={inlineStyle}>

</style>

<script src="https://polyfill.io/v3/polyfill.min.js?features=URLSearchParams">

</script>
<script type="module" define:vars={{ selector, groupSelector, id }}>
    /* https://gomakethings.com/how-to-create-a-search-page-for-a-static-website-with-vanilla-js/ */
    const stopWords = [
        'a',
        'an',
        'and',
        'are',
        "aren't",
        'as',
        'by',
        'can',
        'cannot',
        "can't",
        'could',
        "couldn't",
        'how',
        'is',
        "isn't",
        'it',
        'its',
        "it's",
        'that',
        'the',
        'their',
        'there',
        'they',
        "they're",
        'them',
        'to',
        'too',
        'us',
        'very',
        'was',
        'we',
        'well',
        'were',
        'what',
        'whatever',
        'when',
        'whenever',
        'where',
        'with',
        'would',
        'yet',
        'you',
        'your',
        'yours',
        'yourself',
        'yourselves',
        'the'
    ]

    const input = document.getElementById(id)
    const items = document.querySelectorAll(selector)
    const groups = groupSelector ? document.querySelectorAll(groupSelector) : []

    const FPS_30 = 1000 / 30

    function debounce(fn, timeout = 150) {
        let timer
        return (...args) => {
            clearTimeout(timer)
            timer = setTimeout(() => fn.apply(this, args), timeout)
        }
    }

    const update = () => {
        const regexMap = input.value
            .toLowerCase()
            .split(' ')
            .filter((word) => word.length && !stopWords.includes(word))
            .map((word) => new RegExp(word, 'i'))

        for (const item of items) {
            const isMatch =
                !regexMap.length ||
                regexMap.some((regex) => !!item.textContent.match(regex))
            isMatch
                ? item.removeAttribute('hidden')
                : item.setAttribute('hidden', '')
        }

        for (const group of groups) {
            const matchedItems = group.querySelectorAll(
                `${selector}:not([hidden])`
            )
            matchedItems.length > 0
                ? group.removeAttribute('hidden')
                : group.setAttribute('hidden', '')
        }

        updateURL()
    }

    const updateURL = () => {
        const q = input.value?.trim()

        if (q) {
            const params = new URLSearchParams()
            params.set('q', q)
            window.history.replaceState(null, null, `?${params.toString()}`)
        } else {
            const [href] = window.location.href.split('?')
            window.history.replaceState(null, null, href)
        }
    }

    const hydrateQuery = () => {
        const params = new URLSearchParams(location.search)
        input.value = params.get('q') || ''
    }
    
    const keyDownFocusInput = (event) => {
        if (event.key === '/') {
            event.preventDefault();
            input.focus();
        }
    }

    input.addEventListener('input', debounce(update, FPS_30), true)
    document.addEventListener('keydown', keyDownFocusInput)

    hydrateQuery()
    update()
</script>

<style>
    section {
        @apply flex justify-end w-full;
    }

    label {
        @apply flex rounded-3xl p-1 bg-neutral-50 border border-primary-300 w-full transition duration-300 ease-out relative;
    }

    label:focus-within {
        @apply border-primary-400 shadow shadow-accent-300;
    }

    label::after {
        content: "/";
        @apply absolute border border-primary-400 font-medium text-primary-600 flex h-6 items-center justify-center right-12 rounded-sm text-sm top-3 w-6;
    }

    input {
        @apply pl-3 bg-transparent outline-none w-full;
        line-height: 2.5rem;
    }

    input::placeholder {
        @apply text-primary-900 opacity-75;
    }

    div {
        @apply flex items-center justify-center w-10 h-10 rounded-full text-primary-700;
    }

    @media (max-width: 768px) {
        label, section {
            @apply w-full;
        }

        input {
            @apply flex-1 max-w-none;
        }
    }

    @media(hover: hover) {
        label {
            @apply bg-transparent;
        }

        input, div {
            transition: 250ms ease;
        }

        input:focus,
        input:not(:placeholder-shown) {
            padding: 0 .5rem;
            padding-left: 0.75rem;
        }

        label:hover {
            @apply bg-neutral-50;
        }

        label:hover > input {
            padding: 0 .5rem;
            padding-left: 0.75rem;
        }

    }
</style>